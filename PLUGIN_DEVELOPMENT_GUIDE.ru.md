# Руководство по разработке плагинов для Heroes of Might & Magic III ERA (Monorepo h3era_plugins)

Это расширенное руководство создано на основе существующих инструкций (`.github/copilot-instructions.md1`) и дополнено подробной картографией API из каталога `headers/H3API_for_copilot`. Каталог `H3API_for_copilot` используется исключительно как источник справочной информации для Copilot Ask / Agent / Edits и НЕ должен копироваться в код новых плагинов (используйте уже подключённые в проекте заголовки из `headers/`).

## 1. Общая архитектура монорепозитория
- Все плагины (DLL) находятся в корневых подпапках: `Assembly_MainPlugin/`, `Interface_*`, `Graphics_*`, `RMG_*`, `Artifacts_*`, и т.д.
- Общие заголовки и типы: папка `headers/` (включает фактический API, используемый в сборке). Папка `headers/H3API_for_copilot` — справочная (индексация для автодополнения и подсказок).
- Единые настройки сборки задаются в `Directory.Build.props` и *локально* переопределяются через `Directory.Build.props.user`.
- Решение Visual Studio: `H3EraPlugins.sln`.
- Каждый плагин — минимальный DLL-модуль с классическим `dllmain.cpp` и небольшим набором *.cpp/*.h файлов.

## 2. Конвенции и обязательные элементы плагина
| Элемент | Правило |
|---------|--------|
| `framework.h` | Содержит `#pragma once`, `#define WIN32_LEAN_AND_MEAN` и `#include "../headers/header.h"` — без лишних include. |
| `dllmain.cpp` | Объявляет глобальные: `Patcher *globalPatcher = nullptr;` и `PatcherInstance *_PI = nullptr;` + функция инициализации. |
| Пространство имён `dllText` | Метаданные плагина: имя, автор, версия, дата. |
| Подключение API | Использовать общий `header.h` (косвенно тянет нужные H3* структуры). |
| Нет дублирования era.cpp | Не создавать в плагине — используется общий `../headers/Era/era.cpp` через проект. |
| Стиль | Следовать образцам `Assembly_MainPlugin` и минимальных плагинов (`Interface_MainMenuAPI`). |

## 3. Назначение каталога `H3API_for_copilot`
Эта директория содержит агрегирующие заголовки вида `H3Artifacts.hpp`, `H3AdventureMap.hpp` и т.д. Каждый такой файл просто включает набор тематических заголовков из пространства `h3api/…`. Это:
- Ускоряет навигацию и индексирование символов для инструментов ИИ.
- Позволяет быстро найти, в каком подпакете лежат нужные структуры.

Вы НЕ импортируете напрямую файлы из этой папки в продакшен-код. Вместо этого используете уже настроенный единый include через `framework.h` → `../headers/header.h`.

## 4. Карта модулей API (обзор)
Ниже приведены агрегирующие файлы и их содержимое по доменам. Это даст быстрое понимание, где искать типы.

### 4.1 Артефакты (`H3Artifacts.hpp`)
Включает:
- `H3Artifact.hpp` — базовая структура артефакта (идентификатор, слоты, типы эффектов).
- `H3ArtifactSetup.hpp` — данные настройки / инициализации артефактов.
- `H3CombinationArtifacts.hpp` — логика комбинированных артефактов (состав, бонусы).
Использование: чтение параметров артефакта, проверка типа, добавление в инвентарь героя, реакции на экипировку.

### 4.2 Данные игры (`H3GameData.hpp`)
Включает (ключевые элементы сценария и условий):
- `H3Main`, `H3MainSetup` — центральные структуры состояния партии.
- `H3MapInfo`, `H3ScenarioMapInformation` — метаданные карты (размер, уровень воды, шаблон, игроки).
- `H3Resources` — глобальные ресурсы игрока.
- `H3Spell` — описание заклинаний в контексте карт/битв.
- `H3GlobalEvent`, `H3LossCondition`, `H3VictoryCondition` — условия сценария.
- `H3TurnTimer` — тайминг ходов (сетевые сессии).
- `H3GarrisonInterface` — взаимодействие с гарнизонами.
- `H3RandomDwelling` — логика случайных жилищ.
- `H3Network` — сетевые параметры.
Использование: доступ к глобальному состоянию, проверка условий победы/поражения, управление ресурсами.

### 4.3 Менеджеры (`H3Managers.hpp`)
- `H3AdventureManager` — управление состоянием приключенческой карты (герои, объекты, переходы).
- `H3CombatManager` — контекст текущей битвы (стек юнитов, состояние поля, эффекты).
- `H3ExecutiveMgr` — высокоуровневый цикл / планировщик.
- `H3HiScoreManager` — таблицы рекордов.
- `H3InputManager`, `H3MouseManager` — ввод пользователя.
- `H3RecruitManager` — набор существ.
- `H3SoundManager` — звуки / музыка.
- `H3SwapManager` — обмен артефактами / сущностями.
- `H3TownManager` — взаимодействие с городами (здания, гарнизон, рынок).
- `H3WindowManager` — работа с игровыми окнами и диалогами.
Использование: перехват игровых фаз, модификация UI, внедрение действий при наступлении событий.

### 4.4 Приключенческая карта (`H3AdventureMap.hpp`)
Содержит обёртки для ВСЕХ типов объектов карты: артефакт, лодка, шахта, событие, герой, монстр, университет, гробница, мельница и т.д. Примеры:
- `H3MapHero` — данные героя на карте (позиция, ссылки на `H3Hero`).
- `H3MapMonster` — существа-охрана / нейтралы.
- `H3MapTown` — города на карте.
- `H3MapMine`, `H3MapCampfire`, `H3MapTreasureChest` — ресурсные объекты.
- `H3MapBlackMarket`, `H3MapUniversity`, `H3MapSeerHut` — специальные интерактивные объекты.
- `H3ObjectAttributes`, `H3ObjectDetails` — общая метаинформация объекта.
- `H3TileVision` — информация видимости тайла.
Использование: сканирование карты, модификация охраны, динамическое создание объектов (через патчинг), чтение координат.

### 4.5 Рандом-генератор карт (RMG, `H3RMG.hpp`)
Типы отвечают за шаблоны и генерацию зон:
- `H3RmgTemplate`, `H3RmgZone`, `H3RmgZoneGenerator`, `H3RmgRandomMapGenerator` — ядро генерации.
- `H3RmgObject*` (Monster, Town, Seer, etc.) — различные объектные фабрики.
- `H3RmgParameters` — набор параметров генерации.
Использование: модификация логики шаблонов, кастомное распределение объектов, настройка связей зон.

### 4.6 Навыки (`H3Skills.hpp`)
- `H3PrimarySkills`, `H3SecondarySkill` — базовые и вторичные навыки.
- Спец. файлы типа `H3Diplomacy` — логика взаимодействия с нейтралами.
Использование: изменение формул навыков, внедрение бонусов, пересчёт параметров героя.

### 4.7 Города (`H3Towns.hpp`)
- `H3Town` — структура города (здания, гарнизон, постройки).
- `H3SetupTown` — параметры генерации города.
- `H3CastleEvent` — события города.
- `H3TownCreatureTypes`, `H3TownDependencies`, `H3BuildingCosts` — экономика и прогресс построек.
Использование: моддинг экономики, изменения требований, динамика найма.

### 4.8 Юнит-контейнеры и аллокаторы (`H3Containers.hpp`, выборочно)
- Шаблонные структуры `H3Map<T>`, `H3FastMap<T>` (см. `H3Base/H3Core.hpp`).
- Специализированные аллокаторы `H3AllocatorReference`.
Использование: оптимизированные контейнеры для интеграции с внутренними структурами игры.

### 4.9 Низкоуровневые базовые типы (`H3Base/*`)
- Версия (`H3Version`), конфиг (`H3Config`), вспомогательные макросы.
Использование: проверка версии API, условная компиляция.

### 4.10 Диалоги и UI (`H3Dialogs.hpp`, `H3DialogControls/*`)
- Контролы: текст, PCX, hint bar (`H3DlgHintBar`), highlightable элементы.
- Менеджмент окон через `H3WindowManager`.
Использование: добавление кнопок, панелей, всплывающих подсказок.

### 4.11 Утилиты (`H3Utilities.hpp`)
- Вспомогательные функции (логирование, строковые операции, работа с ресурсами). 

### 4.12 Версия (`H3Version.hpp`)
Предоставляет макросы:
```
_H3API_VERSION_MAJOR_
_H3API_VERSION_MINOR_
_H3API_VERSION_BUILD_
_H3API_VERSION_
_H3API_VERSION_TEXT_
```
Использование: Контроль совместимости при загрузке плагина.

## 5. Шаблон минимального нового плагина
Структура каталога (пример `MyNewPlugin/`):
```
MyNewPlugin/
  MyNewPlugin.vcxproj
  MyNewPlugin.vcxproj.filters
  MyNewPlugin.vcxproj.user (личный)
  framework.h
  dllmain.cpp
  FeatureLogic.cpp (опционально)
  FeatureLogic.h  (опционально)
  pch.h / pch.cpp (если копируете из шаблона)
```

### 5.1 Пример `framework.h`
```cpp
#pragma once
#define WIN32_LEAN_AND_MEAN
#include "../headers/header.h"
```

### 5.2 Пример `dllmain.cpp`
```cpp
#include "framework.h"

Patcher* globalPatcher = nullptr;
PatcherInstance* _PI = nullptr;

namespace dllText {
    constexpr char InstanceName[]    = "EraPlugin.MyNewPlugin.daemon_n";
    constexpr char PluginAuthor[]  = "daemon_n";
    constexpr char PluginVersion[] = "1.0.0";
    constexpr char PluginDate[]    = __DATE__;
}

// Инициализация (вызов при загрузке)
void StartPlugin() {
    // Создаём патчер и инстанс
    globalPatcher = GetPatcher();
    _PI = globalPatcher->CreateInstance(dllText::InstanceName);

    
    // TODO: Ваши хуки / модификации
}

// Точка входа DLL
BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        StartPlugin();
        // подключение ERA
        Era::ConnectEra(hModule, dllText::InstanceName);
    }
    return TRUE;
}
```

## 6. Подключение логики и работа с API
Основной include: только `framework.h`. Внутри кода используйте нужные структуры напрямую: `H3Hero`, `H3Artifact`, `H3Main`, `H3AdventureManager`, и т.д. Инструменты автодополнения (Copilot) найдут их через индексированную копию (`H3API_for_copilot`).

## 7. Типичные сценарии и примеры

### 7.1 Доступ к текущему бою
```cpp
if (auto cm = H3CombatManager::Get()) {
    auto attacker = cm->hero[0];
    auto defender = cm->hero[1];
    // Манипуляция полем боя, проверка стека и т.д.
}
```

### 7.2 Проверка и добавление артефакта
```cpp
int artId = ARTIFACT_SWORD_OF_JUDGEMENT; // пример
if (!hero->HasArtifact(artId)) {
    hero->GiveArtifact(artId);
}
```

### 7.3 Изменение ресурсов игрока
```cpp
H3Main* main = *P_Main;
H3Player* player = main->GetPlayer(P_CurrentPlayerID);
player->resources.gold += 5000;
```

(Приведённые вызовы являются иллюстративными: уточняйте точные поля/методы в реальных заголовках.)

## 8. Хуки и патчи
Обычно вы:
1. Получаете `globalPatcher = GetPatcher();`
2. Создаёте `_PI = globalPatcher->CreateInstance("PluginName");`
3. Используете методы патчера для вставки JMP/CALL или переписи байтов (см. примеры в `Assembly_MainPlugin`).
4. Регистрируете callback’и на события (если поддерживается вашим окружением).

Советы:
- Минимизируйте область перехвата — патчите конкретные инструкции.
- Логируйте успешную установку хука.
- Проверяйте версию API через `_H3API_VERSION_` при необходимости.

## 9. Отладка
- Сборка Debug конфигурации выбранного проекта.
- Запуск игры под отладчиком: точки останова в вашем коде будут срабатывать при вызове.
- Используйте лог-функции (например `Era::WriteStrToIni(const char* Key, const char* Value, const char* SectionName, const char* FilePath)` и `Era::SaveIni(const char* FilePath)`) для записи поведения в файл журнала.

## 10. Производительность и безопасность
- Избегайте тяжёлых аллокаций внутри игровых циклов (боевой тик, отрисовка UI).
- Проверяйте указатели на `nullptr` перед использованием.
- Не модифицируйте контейнеры игры во время итерации без копии/буфера.

## 11. Стратегия работы Copilot / Agent
Чтобы получить максимально релевантные подсказки:
- При обращении к структурам начинайте ввод с префикса `H3` (например, `H3Map`, `H3Hero`, `H3Artifact`).
- Для UI ищите `H3Dlg`, `H3WindowManager`, `H3DlgHintBar`.
- Для генератора карт — комбинации `H3Rmg*`.
- Не добавляйте заголовки из `H3API_for_copilot` вручную — они служат только индексом.

## 12. Расширение и поддержка
Если вам нужен новый доступ к внутренним структурам:
1. Найдите ближайший аналог в `H3API_for_copilot`.
2. Посмотрите родственные файлы (одинаковый префикс).
3. При необходимости добавьте безопасную обёртку / вспомогательную функцию в своём плагине.

## 13. Частые ошибки
| Ошибка | Как избежать |
|--------|--------------|
| Дублирование `era.cpp` | Не добавлять файл; полагайтесь на общий include. |
| Лишние include в `framework.h` | Храните минимализм — один общий header. |
| Патч по неверному адресу | Сверяйте сигнатуру инструкции / версию игры. |
| Игнорирование версий API | Используйте `_H3API_VERSION_` для условной логики. |
| Перезапись памяти без выравнивания | Используйте предоставленные утилиты патчера. |

## 14. Чеклист перед коммитом
- [ ] Плагин собирается в Debug и Release.
- [ ] Нет прямых include из `H3API_for_copilot`.
- [ ] Глобальные переменные патчера объявлены.
- [ ] Метаданные в `dllText` заполнены.
- [ ] Логи и отладочные сообщения адекватны и не спамят.
- [ ] Нет лишних временных файлов.

## 15. Дальнейшие улучшения (предложения)
- Добавить единый вспомогательный модуль логирования с уровнями (Info/Warning/Error).
- Создать шаблон-хук для типовых операций (например, перехват боевого урона).
- Документировать ключевые структуры `H3Hero`, `H3Town`, `H3CombatCreature` прямо в вики.

---
**Примечание**: Если точные названия полей/методов отличаются — ориентируйтесь на актуальные объявленные типы в реальных заголовках из `headers/`. Каталог `H3API_for_copilot` служит обзорной картой.

Удачной разработки модулей! Если нужно расширить это руководство — добавьте новый раздел PR-ом.
